### 文档：PTY（交互式 `exec`）工具输出的终端渲染方案设计

#### 1. 背景与问题

当前在对话工具调用场景中，部分工具（尤其是以 **PTY/交互式**方式执行的 `exec`）会输出大量 ANSI/VT 控制序列，例如：

- 颜色控制：`\x1b[38;5;79m`
- 光标显示/隐藏：`\x1b[?25l`、`\x1b[?25h`
- 清屏/移动光标等 CSI 序列

当这些输出被当作普通文本或 Markdown 渲染时，会出现用户看到“乱码”的现象（本质不是编码问题，而是**终端控制码未被解释**）。

#### 2. 目标

- **正确展示** PTY/ANSI 输出（颜色、布局、光标控制等应被终端语义解释）
- 在 UI 中提供一致的查看体验（侧边栏/面板展示完整输出，必要时主对话区只保留摘要）
- 不引入安全风险（不将工具输出当作 HTML 注入）
- 性能可控（输出可能是高频 delta，避免卡顿）

非目标（阶段 1 不做）：

- 在 UI 内真正“交互式输入”驱动 PTY（stdin 回传、选择器输入等）

#### 3. 总体方案概述

将“工具输出展示”分为两种渲染路径：

- **PTY 输出**：使用终端模拟器（推荐 `xterm.js`）渲染
- **非 PTY 输出**：继续走 Markdown/纯文本渲染（并进行 sanitize）

核心在于：**稳定识别 PTY 输出**，并在 UI 层将其路由到终端渲染组件。

#### 4. 数据识别策略（PTY 判定）

按优先级：

##### 4.1 显式标记（最可靠）

当工具调用参数带 `pty: true`（或网关明确字段）时，判定为 PTY 输出。

- **优点**：零误判
- **缺点**：依赖后端/工具调用协议稳定携带该字段

##### 4.2 启发式检测（回退）

当缺少显式标记时，检测输出中是否包含 ANSI 转义序列（`\x1b[`、`\u009b` 等）。

注意事项：

- **不要**使用带 `g` 的正则直接 `.test()`（JS 正则带 `g` 时 `.test()` 有状态，可能产生偶发误判）
- 推荐：
  - 维护一个“无 `g` 的 test 正则”用于 `test`
  - 维护一个“有 `g` 的 replace 正则”用于 `strip`

#### 5. UI 渲染策略

##### 5.1 侧边栏（推荐承载完整输出）

- 标题可区分：
  - PTY：`Terminal Output`
  - 非 PTY：`Tool Output`
- PTY 内容使用 `terminal-viewer`（内部 xterm.js）渲染
- 非 PTY 内容继续使用 Markdown 渲染（sanitize）

##### 5.2 对话流（避免信息噪音）

建议对话区只保留：

- 工具卡片（工具名、状态、命令摘要）
- 可选：PTY 输出的短预览（可用终端组件的 preview 模式）

完整输出仅在侧边栏展示，避免把大量终端噪音放入对话主区域。

#### 6. 数据传递方案（两种可选）

##### 6.1 方案 A：字符串协议（最小改动）

侧边栏内容仍是 `string`，但用一个前缀标记表明内容类型：

- PTY：`__PTY_OUTPUT__` + 原始输出
- 非 PTY：原样 Markdown/文本

优点：

- 改动小，接入快
  缺点：
- 语义不够强、容易误用

##### 6.2 方案 B：结构化类型（更强健）

将 sidebar content 从 `string` 升级为结构化：

- `{ type: "pty"; text: string }`
- `{ type: "markdown"; text: string }`

优点：

- 类型安全，不依赖“字符串协议”
  缺点：
- 需要调整状态管理与 props 传递，改动面更大

**建议**：阶段 1 用 A 快速落地，阶段 2/3 再演进为 B。

#### 7. 性能与更新策略

PTY/交互式输出通常是高频、碎片化 delta：

- **阶段 1（简单可靠）**：侧边栏每次打开时渲染当前完整内容（一次性写入）
- **阶段 2（优化体验）**：支持增量写入
  - tool 输出流式追加时调用 `term.write(delta)` 而不是重置全量内容
  - UI 层做节流（例如每 16–50ms 合并一次 delta）减少渲染抖动

#### 8. 安全考虑

- PTY 输出必须走终端渲染组件（xterm/canvas/dom 受控渲染），**不要**走 `unsafeHTML`
- Markdown 渲染继续使用 sanitize（已有 sanitize 路径则复用）
- 提供“复制”能力时建议两种：
  - 复制纯文本（先 strip ANSI）
  - 复制原始输出（保留 ANSI，供用户粘贴到真实终端复现）

#### 9. 边界情况与体验细节

- **误判为 PTY**：普通文本在终端里也能显示，只是风格不同，风险较低
- **漏判为 PTY**：会出现“乱码”控制码，这是必须避免的，因此应优先确保判定可靠
- **交互式提示无法输入**（阶段 1 的限制）：允许展示提示内容，但不支持 UI 内继续交互；必要时在卡片/侧边栏提示“该输出来自交互式程序，UI 不支持输入，仅供查看”

#### 10. 迭代计划（推荐）

- **阶段 1：MVP（解决乱码）**
  - PTY 判定：`args.pty` + ANSI 回退
  - 侧边栏：PTY 用 terminal-viewer 渲染
  - 对话流：只保留工具卡片 + 可选短预览

- **阶段 2：体验完善**
  - 修复 ANSI 检测的状态问题（避免偶发漏判）
  - 工具卡片预览用 terminal preview
  - 增加复制/下载 raw log

- **阶段 3：真正交互式**
  - UI 输入 → gateway → PTY stdin 回传
  - 会话/权限/超时/中断机制
  - 交互式组件（选择器/确认框）可视化（可选）

---

### 最终摘要

该方案**可行且推荐**：通过“PTY 识别 + xterm.js 终端渲染”的路径，能从根本上解决交互式 `exec` 输出的 ANSI 控制码乱码问题；同时把完整输出收敛到侧边栏展示，避免污染对话主区域。后续可逐步从“仅展示”演进到“可交互输入回传”的完整 PTY 体验。
